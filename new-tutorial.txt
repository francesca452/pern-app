FULL STACK APPLICATION: https://www.youtube.com/watch?v=lx3YJj0nJVk&t=10025s
DATABASE CONNECTION: https://www.youtube.com/watch?v=VaJPdtuql8k

BACKEND:
    1. "cd pern-app" (move to the folder "pern-app" in local computer)
    
    2. "code ." (open the folder on our IDE)
    
    3. "mkdir backend" (create new folder "backend")
    
    4. "mkdir frontend" (create new folder "frontend")
    
    5. "nmp init -y"
    [*]

    6. "npm i express dotenv cors helmet morgan pg @arcjet/node"
    (installation of packages or libraries in the main folder enviorment.
    You can see the depencencies in package.json file under the depencencies tag)
    
    7. Create new file "\backend\server.js"
    
    8. Go to package.json, modify "main" entry point: from "index.js" to "backend/server.js"

    9. In package.json below "author" insert new entry point: "type": "module".
    The default type is "commonjs". 
    -- commonjs: const express = require("express");
    -- module: import express from "express";

    10. In server.js write:
        ## 
        import express from "express";

        const app = express();
        const PORT = 3000;
        app.listen(PORT, () => {
            console.log(`Server is running on port ${PORT}`);
        });
        ##
    The server is running on port 3000 port. 
    You can change the port: "app.listen(3001, ...)".

    11. Run the server by typing in the terminal; "node backend/server.js".
    We see: "Server is running on port 3000".
    "[nodemon] clean exit - waiting for changes before restart" means that
    the connection to the server is shut down.
    To avoid having to reset the server everytime we need to use nodemon instead.

    12. "npm i nodemon -D".
    In package.json there is something new: "devDependencies".

    13. Create a script in package.json: delete the old one "test" and write
    "dev": "nodemon backend/server.js".
    In terminal run the server: "npm run dev".
    If you don't see: "[nodemon] clean exit - waiting for changes before restart"
    the connection is still on.

    14. First request in server.js:
        ##
        app.get("/", (req,res) => {
            res.send("Hello from the backend");
        });
        ## 
    The responce is visible in the browser: "http://localhost:3000/".
    We can have also change the route:
        ##
        app.get("/test", (req,res) => {
            res.send("Hello from the test route");
        });
        ##
    The link now is: "http://localhost:3000/test".
    At the wrong page you'll receive the message: "Cannot GET /".


A middleware is a function that has access to the request object (req),
the responce object (res) and the next middleware function in the application's 
request-responce circle. A series of steps or checkpoints that every incoming http 
request must pass through before it reaches its final destination (the 
route handler). Each function on the line performs a specific task on the request
or prepares the response.
The next parameter is what allows the processing to move forward.


    15. We want to create an API. 
    In server.js write what follows and insert middleware.
        ##
        import helmet from "helmet";

        const app = express();
        app.use(helmet());

        app.get("/test", (req,res) => {
            console.log(res.getHeaders());
            res.send("hello from the test route");
        });
        ##
    In the browser we see a lot of headers information.
    Goal of "helmet": is a security middleware that helps to protect
    your app by setting various HTTP headers.
    (other configuration: 
    app.use(helmet({ contentSecurityPolicy: false })); 
    )

    16. Another middleware:
        ##
        import morgan from "morgan";
        
        const app = express();
        app.use(morgan("dev"));
        ##
    "morgan" is used for logging information about the request (path, method,
    status code, response time).
    
    17. Others middleware:
        ## 
        import express from "express";
        import cors from "cors";

        app.use(express.json());
        app.use(cors());
        ##
    -- express.json: to read the body of an incoming request (json data)
    and makes it accessible on req.body.
    -- cors: used for security, like helmet.

    18. Create the .env file in main folder to set the environment variables.
    Spaces are not allow: NOT "PORT = 3000".
    PORT has to be all uppercase because is a constant.
    In .env file: PORT=3000
    
    19. Go back to server.js and write:
        ##
        import dotenv from "dotenv";

        dotenv.config({ quiet: true });
        const PORT = process.env.PORT || 3000;
        ##
    "quiet: true" is used to hide in the console any dotenv promotional tip.
    When "dotenv.config()" runs, it looks for ".env" in the current working
    directory (pern-app) which is exactly where your ".env" file is located.

    20. Change the root for the request: "/api/parkingSpots".
    For example, the get request to all the elements from the database give the responce:
        ##
        res.status(200).json({
            success: true,
            data: [ 
                { id: 1, name: "Parking spot 1" },
                { id: 2, name: "Parking spot 2" },
                { id: 3, name: "Parking spot 3" }    
            ],
        });
        ##
    
    21. To organize all the requests, we create two files under two new folders:
    -- routes > parkingSpostRoutes.js
    -- controllers > parkgingSpotControllers.js
    In server.js we delete the testing route:
        ##
        app.get("/api/parkingSposts", (req,res) => {
            res.send("Hello from the test route");
        });
        ##
    and add teh code below that will call the API endpoint:
        ##
        import parkingSpotRoutes from "./routes/parkingSpotRoutes.js";

        app.use("/api/parkingSpots", parkingSpotRoutes);
        ##
    This is another example of routing middleware: directs the request to the
    correct handler function based on the URL path.
    
    22. In parkingSpostRoutes write:
        ##
        import express from "express";
        import { getParkingSpots, getParkingSpot, createParkingSpot, updateParkingSpot, deleteParkingSpot } from "../controllers/parkingSpotController.js";

        const router = express.Router();

        router.get("/", getParkingSpots); 
        router.get("/:id", getParkingSpot); 
        router.post("/", createParkingSpot);
        router.put("/:id", updateParkingSpot);
        router.delete("/:id", deleteParkingSpot);

        export default router;
        ##
    Take for example "router.get("/", getParkingSpots)": if we do a get request at the endpoint obtained by adding 
    at the end of the base url (http://localhost:300/api/parkingSposts) the "/", we will obtain something from 
    the function "getParkingSpots" in the parkingSpotControllers.js file. 
    
    23. For now, only write the function called from the parkingSpotRoutes.js file, without the body:
        ##
        export const getParkingSpots = async (req, res) => {};
        export const getParkingSpot = async (req, res) => {}; 
        export const createParkingSpot = async (req, res) => {};
        export const updateParkingSpot = async (req, res) => {}; 
        export const deleteParkingSpots = async (req, res) => {};
        ##
    Later, we will modify the logic of the requests. Now we don't have the connection to a database

    24. Now we connect our database. 
    Why don't commit the database: the local database contains sensitive data, large files and
    local machine depencencies. The correction solution to connect to it is to use (in the future)
    Docker Compose. For now, we can create in the backend code the essential instructions to
    define the database structure.
    In backend folder create: config > db.js.
        ##
        import { Client } from "pg";
        import dotenv from "dotenv";

        dotenv.config();
        const { PGHOST, PGUSER, PGPORT, PGPASSWORD, PGDATABASE } = process.env;

        const con = new Client({
            host: PGHOST || "localhost",
            user: PGUSER || "postgres",
            port: PGPORT || 5432,
            password: PGPASSWORD,
            database: PGDATABASE || "bicycledb"
        });

        con.connect()
            .then(() => console.log("Connected to database"))
            .catch(err => console.error("Connection error: ", err));

        export const sql = con;
        ##
    
    25. Create the environment variables in .env file:
        ##
        PORT=3000

        PGUSER=postgres
        PGPASSWORD='password'
        PGHOST=localhost
        PGDATABASE=bicycledb
        PGPORT=5432
        ##


To fill the environment variables go to pgAdmin4 application:
-- Servers > PostgreSQL18 > properties > connection
    

    26. Go now in server.js file to initialize new table in the database:
        ##
        import { sql } from "./config/db.js";

        async function initDB() {
            try {
                await sql.query(`
                    CREATE TABLE IF NOT EXISTS parkingArea (
                        id SERIAL PRIMARY KEY,
                        street VARCHAR(255) NOT NULL,
                        tot_available INTEGER NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                `);

            console.log("Database initialized successfully");
            
            } catch (error) {
                console.log("Error initDB:", error);
                process.exit(1);
            }
        }
        ##
    We create a table called "parkingArea" that has these characteristics:
    -- id: unique id, "serial" to have all the parking spots in sequel ids
    -- street: where the parking spot is located 
    -- tot_available: number of total slots in the bicycle parking spot
    -- created_at: indicates at what time the element is created
    

To see the new table created in local database application (pgAdmin4):
-- Servers > PostgreSQL18 > bicycledb > Schemas > public > Tables > parkingArea > View/Edit data > All rows
To add some values to the table:
-- bicycledb > Schemas > public > Tables > parkingsposts > Query tool

-- One row at a time:
   INSERT INTO parkingArea (street, tot_available)
   VALUES ('Via Cirro', 10)
   RETURNING id;

   -- Multiple rows at a time:
   INSERT INTO parkingArea (street, tot_available)
   VALUES
    ('Via Marziale', 5),
	('Via Roma', 18),
	('Via Garibaldi', 7)
   RETURNING id;

Meaning of "RETURNING id": after inserting the rows, gives back the
ids created. Remember not to use "..." but '...'.

To see all the changes:
-- SELECT * FROM parkingArea;


    27. Once we have the right to connect to the database and the code to create the 
    initial table, now we will run the server only after the database is ready.
    In server.js change this:
        ##
        listen(PORT, () => {
            console.log("Server is running on port " + PORT);
        });
        ##
    To this:
        ##
        initDB().then(() => {
            app.listen(PORT, () => {
                console.log("Server is running on port " + PORT);
            });
        });
        ##
    
    28. Now we build all the controllers, all the crud operations.
    We're going to test the functions later with POSTMAN.
    If we visit in the browser: "http://localhost:3000/api/parkingSpots/",
    will be in loading state due to the empty body in the functions.
    So, let's write the function getParkingSpots:
        ##
        import { sql } from "../config/db.js";

        export const getParkingSpots = async (req, res) => {
            try {
                const spots = await sql.query(`
                    SELECT * FROM parkingArea
                    ORDER BY created_at DESC
                `);
        
            console.log(`Found ${spots.rows.length} parking spots`);
            res.status(200).json({
                success: true,
                data: spots.rows
            });

            } catch (error) {
                console.log("Error in getParkingSpots function", error);
                res.status(500).json({
                    success: false,
                    message: "Failed to fetch parking spots",
                    details: error.message
                }); 
            };
        };
        ##
    Visiting now the page at route "http://localhost:3000/api/parkingSposts/" is:
    -- With no elements: {"success":true,"data":[]}
    -- With some anticipated insert: 
    {"success":true,"data":{"command":"SELECT","rowCount":4,"oid":null,"rows":[{"id":4,"street":"Via Cirro","tot_available":10, ...]}}

    29. We go with createParkingSpot().
    We get some data that user will send us, coming from req.body: { street, tot_available }.
    The extraction is possible by the middleware "express.json()".
        ##
        export const createParkingSpot = async (req, res) => {
            const { street, tot_available } = req.body;

            # Validation 
            if (!street || !tot_available) {
                return res.status(400).json({
                    success: false,
                    message: "All fields are required"
                });
            }

            # Validate tot_available is a number
            const totalAvailable = parseInt(tot_available);
            if (isNaN(totalAvailable) || totalAvailable < 0) {
                return res.status(400).json({
                    success: false,
                    message: "Total available parking spots must be a positive number"
                });
            }

            try {
                const newSpot = await sql.query(`
                    INSERT INTO parkingArea (street, tot_available)
                    VALUES ($1, $2)
                    RETURNING *`,
                    [street, totalAvailable]
                ); # Safer than using: ${street} ${tot_available}

                console.log("New spot created");
                res.status(201).json({
                    success: true,
                    data: newSpot.rows[0]
                }); # "newSpot" is a record ([]), so newSpot.rows[0] get the newky created spot

            } catch (error) {
                # [...]    
            };
        };
        ##
    
    30. getParkingSpot is similar to getParkingSpots but get only one spot.
    In parkingSpostRoutes the call is: router.get("/:id", getParkingSpot);
    The parameter "id" has to be in the body function of getParkingSpot.
    (if I choose idx -> then I have to recall the param idx).
        ##
        export const getParkingSpot = async (req, res) => {
            const { id } = req.params; --> # THE ID PARAMS
            
            try {
                const spot = await sql.query(`
                    SELECT * FROM parkingArea WHERE id=$1`, # Remember the comma (,) !!
                    [id] # Safer than: `SELECT * FROM parkingspots WHERE id=${id}`
                );

                # Check if the spot exists
                if (spot.rows.length === 0) {
                    return res.status(404).json({
                        success: false,
                        message: "Parking spot not found"
                    });
                }
        
                console.log("Fetched spot");
                res.status(200).json({
                    success: true,
                    data: spot.rows[0]
                });

            } catch (error) {
                # [...]
            };
        }; 
        ##

    31. updateParkingSpot, in the routes file: "router.put("/:id", updateParkingSpot)".
    Because the user would like to update one of this fields, or maybe all of them,
    they are both required (maybe that can change in the next update).
        ##
        export const updateParkingSpot = async (req, res) => {
            const { id } = req.params;
            const { street, tot_available } = req.body;
    
            try {
                const updatedSpot = await sql.query(`
                    UPDATE parkingArea
                    SET street=$1, tot_available=$2
                    WHERE id=$3
                    RETURNING *`,
                    [street, tot_available, id]
                );
                
                # We also add a check
                if (updatedSpot.length === 0) { # If correct, that means product is not found
                    return res.status(404).json({
                        success: false,
                        message: "Spot not found"
                    });
                }
        
                console.log("Succesfully updated");
                res.status(200).json({
                    success: true,
                    data: updatedSpot.rows[0]
                });

            } catch (error) {
                # [...]
            };
        };
        ##
    

    32. Last one function: deleteParkingSpot.
    It's very similar to updateParkingSpot.


Test the function of parkingSpotControllers in Postman.
Soon we will do the same request from the frontend application.
-- New workspace from a blank project > call it "PARKINGAREA" > create new request ("+" in PARKINGAREA collection)
For get request: rename it "GET ALL PARKING SPOTS".
Type the endpoint: "http://localhost:3000/api/parkingSpots/" 
REMEMBER: the server have to be online!
"PS C:\Users\mazze\pern-app> npm run dev", until the the log message "Server is running on port 3000".
Conclude the Postman request with "send": the responce status will be "200 OK". 

Do same thing with the other functions: POST, "CREATE NEW PARKING SPOT".
In the body section insert "street" and "tot_available", like in the parkingSpotControllers code:
{
    "street":"Via ...",
    "tot_available":40 # positive number!
}
Responce will be:
{
    "success": true,
    "data": {
        "id": 8,
        "street": "Via Rizzoli",
        "tot_available": 40,
        "created_at": "2025-11-21T11:03:32.529Z"
    }
}
You can control the newly row by the "GET ALL PARKING SPOTS" API request.

Other request: GET, "GET A SINGLE PARKING SPOT", with endopoint "http://localhost:3000/api/parkingSpots/:id".
For the "id" params:
-- Insert the id in the params section (Path Variables > id)
-- Change the "/:id" with the specific one, like "http://localhost:3000/api/parkingSpots/4"
Sending the request, you'll receive "success:true" with all the attributes.

Request: DELETE, "DELETE A SINGLE PARKING SPOT".
Like the GET request, insert the id of the parking spot.

Request: PUT, "UPDATE PARKING SPOT".
For now, is necessary both elements "street" and "tot_available", even if they remain unchanged:
{
    "street":"Via Don Bedetti 89",
    "tot_available":5
}
In params body, insert also the id number.


    33. Implementation of rate limiting, for limiting network traffic. 
    It puts a limit on how often someone can repeat an action within a certain timeframe
    (like a malicious user that wants to send 1000 req/sec).
    Our server would crash in that case, we can't handle that amount of requests per sec.
    So, we're going to put a limit: every user can only send x requests per minute.
    We can keep track of single user or all of them by the IP address.
    We're implementing also bot detection and Shield.

    Go to official documentation of Arcjet: arcjet > Docs > Node.js + Express
    (https://docs.arcjet.com/get-started?f=node-js-express):
    Requested:
    -- "npm install express": already done
    -- "npm i @arcjet/node @arcjet/inspect"
    -- Set the keys in .env file:
        ##
        ARCJET_KEY=... (copy when creating new account)
        ARCJET_ENV=development (tells Arcjet you're working locally)
    
    34. To complete the arcjet installation, we add some code in: lib > arcjet.js
    "lib" is chose for configure third parties libraries.
    Then look and copy from the documentation:
        ##
        import arcjet, { tokenBucket, shield, detectBot } from "@arcjet/node";

        const aj = arcjet({ # Initialize Arcjet
            key: process.env.ARCJET_KEY,
            characteristics: ["ip.src"],
            rules: [
                shield({ mode:"LIVE" }),
                detectBot({
                    mode:"LIVE",
                    allow:["CATEGORY:SEARCH_ENGINE"],
                }),
                tokenBucket({
                    mode: "LIVE",
                    refillRate: 30,
                    interval: 5,
                    capacity: 20
                }),
            ],
        });

        export { aj };
        ##
    "tokenBucket" algorithm params:
    -- refillRate: 30 (how many tokens we're going to get)
    -- interval: 5 (seconds)
    -- capacity: 20 (tokens)
    -- requested: 1 (each request consumes 1 token)
    Initialization with 20 tokens, to be used within 5 seconds.
    After the interval time has elapsed, there is a refill of 30 tokens.
    Other algorithm: slidingWindows (instead of tokenBucket).

    Other consideration: it's not necessary to call "dotenv" package must be the first import in entry file (server.js),
    so environment variables are loaded before any other module tries to use them.
    We don't need to import dotenv also in "arcjet.js" file.

    35. In server.js connect arcjet:
        ##
        import { aj } from "./lib/arcjet.js";
        import { isSpoofedBot } from "@arcjet/inspect";

        app.use(async (req,res,next) => {
            try {
                const decision = await aj.protect(req, { requested:1 });

                if (decision.isDenied()) {
                    if (decision.reason.isRateLimit()) {
                        return res.status(429).json({ error: "Too many requests" });
                    } else if (decision.reason.isBot()) {
                        return res.status(403).json({ error: "No bots allowed" });
                    }
                    return res.status(403).json({ error: "Forbidden" });
            
                } else if (decision.ip.isHosting()) {
                    return res.status(403).json({ error: "Forbidden" });
            
                } else if (decision.results.some(isSpoofedBot)) {
                    return res.status(403).json({ error: "Forbidden" });
                } 
        
                next();

            } catch (error) {
                console.log("Arcjet error", error);
                next(error);
            }
        });
        ##
    
    36. To seeding the database, create a new folder in "backend".
    "seeds", and then the file "spots.js".
    Seeding the database mean that we'll just add some test data tjat we can use.
    In the development process you would like to just add the data into the db, 
    instead of creating manually.
    "
    import { sql } from "../config/db.js";

    const SAMPLE_SPOTS = [
        {
            street: "Via Zamboni 33",
            tot_available: 30,
        },
        {
            street: "Via Antonio 9/3a",
            tot_available: 15,
        },
    ];

    async function seedDatabase() {
        try {
            // First, clear existing data
            await sql.query(`TRUNCATE TABLE parkingspots RESTART IDENTITY`);

            // Insert all spots
            for (const spot of SAMPLE_SPOTS) {
                await sql.query(`
                    INSERT INTO parkingspots (street, tot_available)
                    VALUES ($1, $2)`,
                [spot.street, spot.tot_available]
            );
            }

            console.log("Database seeded successfully");
            process.exit(0); // Success code

        } catch (error) {
            console.error("Error seeding database:", error);
            process.exit(1); // Failed code
        }
    }

    seedDatabase();
    "
    We're testing the function by opening new terminal:
    "...\pern-app> node backend/seeds/spots.js" and run.
    Now If you refresh on the web app, you will see the newly database.








--------------------------------------------------------------------

















FRONTEND IMPLEMENTATION
We'll create frontend application.

1. Go to terminal: "cd frontend"
2. "npm create vite@latest ." // To initialized it into the frontend folder
3. Choose "React" and "Javascript" (for beginner friendly, but can be used also Typescript)
(Need to reinstall the latest version of Node.js)
4. npm install
5. npm run dev 
6. We can visit local: http://localhost:5137/.
You will see a 'default' react application.
7. We cancel some files:
- "frontend/src/App.css"
- "frontend/src/assets"
- In "frontend/src/App.jsx" cancel all the text and write new one:
"
function App() {
    return (
        <div>
            <h1>hey</h1>
        </div>
    );
}

export default App
"

8. Use Tailwindcss version 3.4.17: click in the top left choise version (v4.1/v3.4.17),
then go to "Docs->Installation->Framework Guides->Vite->Using React"
(https://v3.tailwindcss.com/docs/guides/vite).
In the terminal:
- Create your project: "npm create vite@latest" -> OK
- Install Tailwind CSS: "npm install -D tailwindcss@3 postcss autoprefixer"
- "npx tailwindcss init -p"
Now in frontend folder there're two more files: "postcss.config.js" and "tailwind.config.js"
- Configure your template paths: 
in "tailwind.config.js" file add the code below:
"
[...]
content: [
    "/index.html",
    "./src/**/*.{js,ts,jsx,tsx}"
],
"
- Add the Tailwind directives to your CSS:
in "./src/index.css" file, add the "@tailwind" directive.
Cancel everything that we have in the file and add:
"
@tailwind base;
@tailwind components;
@tailwind utilities;
"

To test the correct connection with Tailwind, go to "frontend/src/App.jsx" and add
a className to the <h1> tag: "<h1 className="text-red-500">".
If it's not available the auto suggestion, go to extensions option of vscode and install:
- Tailwind CSS IntelliSense
- ES7+ React/Redux/React-Native
(for example: if I type "rfce", I will see some default code).

9. "npm run dev" to restart the frontend (the path has to be "[...]pern-app\frontend> npm run dev").
10. Go to DaisyUI v4x and install that, as the pre-built components on top of Tailwind:
(https://v4.daisyui.com/docs/install/).
- In the terminal type: "npm i -D daisyui@v4"
- Add daisyUI to "tailwind.config.js" (using import-export):
"
import daisyui from "daisyui";
export default {
    [...]
    plugins: [daisyui],
}
"
If you want some different daisyui themes, you can add them like:
"
import daisyui from "daisyui";
export default {
    [...]
    plugins: [daisyui],
    daisyui: {
        themes: [
        "pastel",
        "retro", 
        [...]
        ],
    }
}
"

11. Other installation: "npm i react-hot-toast react-router-dom axios zustand lucide-react"
- "react-hot-toast": library that shows notification
- "react-router-dom": allows us to have the navigation in place (to have links, different pages)
- "axios": to fetch data and to send requests (replacement for "fetch API")
- "zustand": for global state
- "lucide-react": package used for icons

12. Create two different folders in "frontend/src": "components" and "pages".
13. In "pages" create "HomePage.jsx" file: type "rfce" to get the initial code.
14. Also create "ParkingSpotsPage.jsx", type rfce.
15. For the components, let's say we have: "Navrbar.jsx".
16. In "App.jsx" delete latest <h1> element and write:
"
import Navbar from "./components/Navbar.jsx";
import HomePage from "./pages/HomePage.jsx";
import ParkingSpotPage from "./pages/ParkingSpotPage.jsx";

import { Routes, Route } from "react-router-dom";

function App() {
  return (
    <div className="min-h-screen bg-base-200 transition-colors duration-300">
      
      <Navbar />

      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/parkingSpot/:id" element={<ParkingSpotPage />} />
      </Routes>

    </div>
  );
}

export default App
"

Import the component and the pages, call it like a tag (React syntax).
"react-router-dom" allows to change the pages by selecting a different route.
For now, the Navbar is fixed on top of the page, and then:
- "htpp://localhost:5173/" --> Navbar / HomePage
- "http://localhost:5173/parkingSpot/23": --> Navbar / ParkingSpotPage

It is just to understand how do the pages work.
What makes this possible is also the "<BrowserRouter>" tag in "main.jsx" page,
that could be also used to incampsule all the code in "App.jsx".
"
createRoot(document.getElementById('root')).render(
  <StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </StrictMode>,
)
"

17. Now we can start the functionality of the navbar.
In the first div:
- <div className="bg-base-100/80 backdrop-blur-lg border-b border-base-conten/10 sticky top-0 z-50">
Then will have one more <div> with some classes:
- <div className="max-w-7xl mx-auto">
Then the wrapper for the navbar class:
- <div className="navbar px-4 minh-[4rem] justify-between">
(the "navbar" is a class of daisyui)
Insert now the logo, once clicked leds to the "HomePage".

The code below comes from Tailwindcss utility classes:
"
import { Link } from "react-router-dom";
import { ShoppingCartIcon } from "lucid-react";
[...]

<div className="flex-1 lg:flex-none">
    <Link to="/" className="hover-opacity-80 transition-opacity">
        <div className="flex items-center gap-2">
            <ShoppingCartIcon className="size-9 text-primary" />
            <span className="font-semibold font-mono tracking-widest text-2xl bg-clip-text text-trasparent bg-gradient-to-r from-primary to-secondary">
                POSGRES PARKING SPOT
            </span>
        </div> 
    </Link>
</div>
"

To change the color theme of the application, go to "App.jsx" theme and in the
<div> in the return section, and add "data-theme" attribute (choose between theme in "tailwind.config.js"):
"
<div className="min-h-screen bg-base-200 transition-colors duration-300" data-theme="cupcake">
"

Now, in "http://localhost:5173" we see the navbar modify.
To add some elements in the right part, we write:
"
import { Link, useResolvedPath } from "react-router-dom";
import { ShoppingBagIcon, ShoppingCartIcon } from "lucide-react";

function Navbar() {
  const { pathname } = useResolvedPath();
  const isHomePage = pathname === "/";

  return(
  [...]

    {/* RIGHT SECTION */}
        <div className="flex items-center gap-4">
            <p>ThemeSelector</p>

            { isHomePage && (
              <div className="indicator">
                <div className="p-2 rounded-full hover:bg-base-200 transition-colors">
                  <ShoppingBagIcon className="size-5" />
                  <span className="badge badge-sm badge-primary indicator-item">
                    8
                  </span>
                </div>
              </div>
            )}
        </div>
  [...]

)
}
"

The hook "useResolvePath" comes from react-router-dom. From this, we destructure the path name:
"isHomePage" will be true if "pathname === "/"", and we can show the element in the {...}:
"
<div className="indicator">
    <div className="p-2 rounded-full hover:bg-base-200 transition-colors">
        <ShoppingBagIcon className="size-5" />
        <span className="badge badge-sm badge-primary indicator-item">
            8
        </span>
    </div>
</div>
"

The 8 stand for element (products, but for our will be parking spots).

Now we can also adjust the "theme color" choice, inserting new component.


[..........]
Look at the commit "theme selection from the navbar"
[..........]


18. Fetch the data that we have in the database.
I don't want to fetch the data in the "HomePage" component, but from another file: "store\useParkingSpotsData.js".
"
import { create } from "zustand";

export const useParkingSpotsData = create((set,get) => ({
    // Spot state
    spots: [],
    loading: false,
    error: null,
}))
"
Once we fetch the spots, the attribute will update.

import { create } from "zustand";
import axios from "axios";

const BASE_URL = "http://localhost:3000";

export const useParkingSpotsData = create((set,get) => ({
    # Spot state
    spots: [],
    loading: false,
    error: null,

    fetchSpots: async () => {
        set({ loading:true }); # Because we're trying to fetch some data
    
        try {
            const response = await axios.get(`${BASE_URL}/api/parkingSpots/`) // We want to send a get request with the help of axios
            set({ spots:response.data.data, error:null });
            
            # Because the first data comes from axios.
            # The second data comes from our API in "parkingSpotControllers.js":
            # -> getParkingSpots() (for example):
            # [...]
            # res.status(200).json({
            # success: true,
            # data: spots.rows --> THIS DATA FIELD
            # });    

            "error:null" because we're in the try (so successfull) field

        } catch (err) {
            # Rate limiting
            if(err.status === 429) set({ error: "Rate limit exceeded" });
            else set({ error: "Something went wrong" });

        } finally { # Either we succeeded or not, we wanna set the loading state to false
            set({ loading:false });
        }
    }
}));

Pay attention:
- In "backend\server.js": "const PORT = process.env.PORT || 3000;"
The localhost set to 3000.
- Also: "app.use("/api/parkingSpots", parkingSpotRoutes);"
Endopoint to do some request: "http://localhost:3000/api/parkingSpots".
- In "backend\routes\parkingSpotRoutes.js": "router.get("/", getParkingSpots);". 
To do get request for "getParkingSpots()" set the endpoint: "http://localhost:3000/api/parkingSpots/".

So, in "frontend\store\useParkingSpotsData.js":
- const BASE_URL = "http://localhost:3000";
- const response = await axios.get(`${BASE_URL}/api/parkingSpots/`)

Now, go to "frontend\pages\HomePage.jsx" and try to call the function to fetch:
"
import React from "react";
import { useEffect } from "react";
import { useParkingSpotsData } from "../store/useParkingSpotsData";

function HomePage() {
  const { spots, loading, error, fetchSpots } = useParkingSpotsData(); 

  # We call the function "fetchSpots" with "useEffect":
  useEffect(() => {
    fetchSpots()
  }, [fetchSpots]);

  console.log("spots:", spots);

  return (
    <div>HomePage</div>
  )
}

export default HomePage;
"

In the console on web, we see spots (6) because these are the elements already in our database.
The get fetch function allows us to fetch the data (without using postman, but directly in the web application).

Now, we want to display them and we're gonna write the code in the "HomePage" return section:
"
import { PlusCircleIcon, RefreshCwIcon } from "lucid-react";
[...]

return (
    <main className="max-w-6xl mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-8">
        -> The functionality of this will be presented later
        <button className="btn btn-primary ">
          <PlusCircleIcon className="size-5 mr-2" />
          Add spot
        </button>

        -> Button to recall the fetch function (refresh the page with all elements)
        <button className="btn btn-ghost btn-circle" onClick={ fetchSpots }>
          <RefreshCwIcon className="size-5" />
        </button>

      </div>
    </main>
  )
"

Code to show an error indicator:
"
import SpotCard from "../components/SpotCard.jsx";
[...]
    <main>
    [...]

      -> Classes come from daisyui:
      -> What we rendere in case of error (not null from the fetch request)
      {error && <div className="alert alert-error mb-8">{ error }</div>}

      -> What we render during loading state:
      {loading ? (
        <div className="flex justify-center items-center h-64">
          <div className="loading loading-spinner loading-lg" />
        </div>
      ) : (
        -> In case of not loading, get each spots and for each spot we wold like 
          to return a component called SpotCard, a component that we're going to create
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {spots.map(spot => (
            <SpotCard key={spot.id} spot={spot} />
          ))}
        </div>
      )}

    </main>
"

Where "components\SpotCard.jsx" is:
"
import React from "react";

function SpotCard({spot}) {
    console.log(spot);

    return (
        <div>SpotCard</div>
    )
}

export default SpotCard;
"
It may has a problem with properties (spot)
(warning in the tutorial was like: spot is missing in props validation eslint(react/prop-types)).
Go to "frontend\eslint.config.js" and scroll to the "rules" field:
"react/prop-types": "off"
--> FOR NOW I DON'T WRITE THIS.

In the web page we can see 6 "SpotCard".
Now, we type some other text in the return field:
"
import React from "react";
import { Link } from "react-router-dom";
import { EditIcon, Trash2Icon } from "lucide-react";

function SpotCard({spot}) {

    return (
        <div className="card bg-base-100 shadow-xl hover:shadow-2xl transition-shadow duration-300">
            
            {/* SPOT IMAGE */}
            {/*
            <figure className="relative pt-[56.25%]">
                <img src={spot.image} alt={spot.street} className="absolute top-0 left-0 w-full h-full object-cover" />
            </figure>
            */}

            <div className="card-body">
                {/* SPOT INFORMATION */}
                <h2 className="card-title text-lg font-semibold">{ spot.street }</h2>
                <p className="text-2xl font-bold text-primary">{spot.tot_aviable}</p>

                {/* CARD ACTIONS:
                - Edit button: once click will take you to the spot page.
                The page will be created later
                - Delete button
                */}
                <div className="card-actions justify-end mt-4">
                    <Link to={`/spot/${spot.id}`} className="btn btn-sm btn-info btn-outline">
                        <EditIcon className="size-4" />
                    </Link>

                    <button className="btn btn-sm btn-error btn-outline">
                        <Trash2Icon className="size-4" />
                    </button>

                </div>

                
            </div>
            

        </div>       
    )
}

export default SpotCard;
"

To see if the rate limiting error work, click in teh web page numerous number of times the refresh button:
you will see the messa in a red box on top of the page saying "Rate limiting exceeded".
When we see this message, we can't see the spots.
Let's fix this:
go to "useParkingSpotsData", in the "catch" field:
"
catch (err) {
    if(err.status === 429) set({ error: "Rate limit exceeded", spots: [] });
    else set({ error: "Something went wrong", spots: [] });    
}
"
Add the "spots: []" to stop seeing the elements.


19. Now, we go back to "useParkingSpotsData" and add a function to delete a product.
The function will be call once you click on the delete icon in "SpotCard".
"
// It's necessary the id of the spot that we're gonna delete
    deleteSpot: async (id) => {
        set({ loading: true });

        try {
            await axios.delete(`${BASE_URL}/api/parkingSpots/${id}`);
            // We're gonna reset the previous state after the delete
            set((prev) => ({ spots: prev.spots.filter(spot => spot.id !== id )}));
            toast.success("Product deleted successfully");

        } catch (err) {
            console.log("Error in deleteSpot function", err);
            toast.error("Something went wrong"); 
        
        } finally {
            set({ loading: false });
        }

    },
"
Need the import of "import toast from "react-hot-toast";", because
we want to see if the spot is deleted (but we don't want to use the same
red message used to rate limiting error).
In "App.jsx" file, we need to add:
"
import { Toaster } from "react-hot-toast"; <-- THIS IMPORT

function App() {
  const { theme } = useThemeStore();
  
  return (
    <div className="min-h-screen bg-base-200 transition-colors duration-300" data-theme={ theme }>
      
      <Navbar />

      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/parkingSpot/:id" element={<ParkingSpotPage />} />
      </Routes>

      <Toaster /> <--- ADD THIS

    </div>
  );
}
"

Now, we can call the function in the "SpotCard" component:
"
<button
    className="btn btn-sm btn-error btn-outline"
    onClick={() => deleteSpot(spot.id)} <-- ADD THIS
>
    <Trash2Icon className="size-4" />
</button><>
"

To finish, we add a comment if the database is empty.
We add some code in "HomePage.jsx" after the error line:
"
import { PlusCircleIcon, RefreshCwIcon, PackageIcon } from "lucide-react";
[...]

{spots.length === 0 && !loading && (
    <div className="flex flex-col justify-center items-center h-96 space-y-4">
        <div className="bg-base-100 rounded-full p-6">
            <PackageIcon className="size-12" />
        </div>
        <div className="text-center space-y-2">
            <h3 className="text-2xl font-semibold">No spots found</h3>
            <p className="text-gray-500 max-w-sm">
              Get started by adding first spots to the inventory
            </p>
        </div>
    </div>
)}
"

20. Add spots.
Clicking the button "Add spot" in the HomePage, we would like to see some kind of modul 
where we can add spot street and tot_available free parking slot, and when submitm it will 
be saved in the database and it will update the web application interface.

Like the other functions, we add in "useParkingSpotsData.js" the function "addSpot".
We need also an object where we can locally write the input to be saved in the database.
"
// Form state
formData: {
    street:"",
    tot_available:0
}
"
Add also a function to help update the form state:
"
setFormData: (formData) => set({ formData }),
resetForm: () => set({ formData: { street:"", tot_available:0 } }),
"

And then the function:
"
// It's gonna take the event "e" because this will be the form submission
addSpot: async (e) => {
    e.preventDefault();
    set({ loading: true });

    try {
    // We want the data from formData. To call them inside a function we used the method "get"
    // as a param of "useParkingSpotsData()"
        const { formData } = get();
        // "formData" is like the req.body
        await axios.post(`${BASE_URL}/api/parkingSpots/`, formData); 
        // To show all the data in the page
        await get().fetchSpots();
        // "resetForm()" because we just add a new spot
        get().resetForm();
        // toast for successfull message
        toast.success("Spot added successfully");
        // Close the modal

    } catch (err) {
        console.log("Error in addSpot function", err);
        toast.err("Something went wrong");

    } finally {
        set({ loading: false });
    }
}
"

We create the component that's gonna be called "addSpotModal".
Go to "HomePage" and write "<AddSpotModal />" just abow the "error" field.
Create in the "components" folder the "AddSpotModal.jsx" file.
In the web interface don't see anything new.

Go to "AddSpotModal.jsx" and write the code for the modal:
(it's possible to go to daisyui web page and copy the element):
"
import React from "react";
import { useParkingSpotsData } from "../store/useParkingSpotsData";
import { Package2Icon, ParkingSquareIcon } from "lucide-react";

function AddSpotModal() {
    const { addSpot, formData, setFormData } = useParkingSpotsData();

    return (
        <dialog id="add_spot_modal" className="modal">
            <div className="modal-box">
                {/* CLOSE BUTTON */}
                <form method="dialog">
                    <button className="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">X</button>
                </form>

                {/* MODAL HEADER */}
                <h3 className="font-bold text-xl mb-8">Add new spot</h3>
                
                <form onSubmit={addSpot} className="space-y-6">
                    <div className="grid gap-6">
                        {/* SPOT STREET INPUT */}
                        <div className="form-control">
                            <label className="label">
                                <span className="label-text text-base font-medium">Street name</span>
                            </label>
                            <div className="relative">
                                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none text-base-content/50">
                                    <Package2Icon className="size-5" />
                                </div>
                                <input 
                                    type="text"
                                    placeholder="Enter spot street name"
                                    className="input input-bordered w-full pl-10 py-3 focus:input-primary transition-colors duration-200" 
                                    value={ formData.street }
                                    onChange={(e) => setFormData({ ...formData, street: e.target.value })}
                                />
                            </div>
                        </div>

                        {/* SPOT TOT_AVAILABLE */}
                        <div className="form-control">
                            <label className="label">
                                <span className="label-text text-base font-medium">Number of free slots</span>
                            </label>
                            <div className="relative">
                                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none text-base-content/50">
                                    <ParkingSquareIcon className="size-5" />
                                </div>
                                <input 
                                    type="number"
                                    min={0}
                                    step={1}
                                    placeholder="0"
                                    className="input input-bordered w-full pl-10 py-3 focus:input-primary transition-colors duration-200"
                                    value={formData.tot_available}
                                    onChange={(e) => setFormData({ ...formData, tot_available: e.target.value })} 
                                />
                            </div>
                        </div>

                    </div>
                </form>
            
            </div>
        </dialog>
    )
}

export default AddSpotModal;
"

In the web page when click on "Add spot" nothing changes. Because we didn't add on click function.
We have to go to "HomePage" file and add "onClick" event in the button tag:
"
<button className="btn btn-primary"
  ---> ADDED:  onClick={() => document.getElementById("add_spot_modal").showModal()}
>
    <PlusCircleIcon className="size-5 mr-2" />
    Add spot
</button>
"

Destructure:
- document: from the document...
- .getElementById("add_spot_modal"): find an element with this id...
That is the <dialog> id in the AddSpotModal return field.
- .showModal(): and we're gonna call the showModal() method.

Now we see the modal open, but we can't close it by touching the background. 
We have to add from ui: go to "AddSpotModal.jsx" and at the bottom of "<dialog>" write
a backdrop component (not a real component)
"
{/* BACKDROP */}
<form method="dialog" className="modal-backdrop">
    <button>close</button>
</form>
"

The only thing that we are missing is the actions: cancel button and a submit button in the modal.
We can add both in the <form> tga into "AddSpotModal.jsx":
"
{/* MODAL ACTIONS */}
<div className="modal-actions">
    <button 
        className="btn btn-ghost mr-3"
        onClick={() => setFormData({ street:"", tot_available:0 })}
    >
        Cancel
    </button>
    <button
        type="submit"
        className="btn btn-primary min-w-[120px]"
        disabled={!formData.street || !formData.tot_available || loading}
    >
        {loading ? (
            <span className="loading loading-spinner loading-sm" />
        ) : (
            <>
                <PlusCircleIcon className="size-5 mr-2" />
                Add spot
            </>
        )}
    </button>
</div>
"

To automatically close the modal once inserted new spot, return to "useParkingSpotsData" from "addSpot":
"
document.getElementById("add_spot_modal").close();
"
in the try field below the "toast.success".


21. Now we build the parking spot page.
Go to "useParkingSpotsData.js" and add new functions: "fetchSpot" and "updateSpot".
We need to create a new state to be able to keep track of the current spot, so when
we click on the web application to the modify icon, we open the page of the spot with the right data.
In the same file, write: "currentSpot: null".
Initially, is going to be null, once we fetch the spot we will make this to be the current spot.

"
fetchSpot: async (id) => {
    set({ loading: true });
        
    try {
        const response = await axios.get(`${BASE_URL}/api/parkingSpots/${id}`);
        set({ currentSpot: response.data.data,
            formData: response.data.data, // Pre-fill the form with current spot data
            error: null,
        });

    } catch (err) {
        console.log("Error in fetchSpot function", err);
        set({ error: "Something went wrong", currentSpot: null });

    } finally {
        set({ loading: false });
    }
},
"

"
updateSpot: async(id) => {
        set({ loading: true });

        try {
            const { formData } = get();
            const response = await axios.put(`${BASE_URL}/api/parkingSpots/${id}`, formData);
            set({ currentSpot: response.data.data });
            toast.success("Spot update successfully");

        } catch (err) {
            toast.error("Something went wrong");
            console.log("Error in updateSpot function", err);

        } finally {
            set({ loading: false });
        }
    },
"

Now go to "ParkingSpotPage" component and destructure the data.
First thing first, we take the values from "useParkingSpotsData".
"
const { 
    currentSpot,
    formData,
    setFormData,
    loading,
    error,
    fetchSpot,
    updateSpot,
    deleteSpot,
  } = useParkingSpotsData();
"
Also other constants from package "react-router-dom":
"
const navigate = useNavigate();
// To be able to fetch the spot id in the url
const { id } = useParams();
--> const is called "id" because in the url that field (.../api/parkingSpots/id) IS CALLED "ID"
"

Add:
"
useEffect(() => {
    fetchSpot(id)
  }, [fetchSpot, id]);

console.log(currentSpot);
"

ATTENTION: correction in "SpotCard" component.
<Link to={`/parkingSpot/${spot.id}`} className="btn btn-sm btn-info btn-outline">

--> Link before doesn't match the url saved in "App.jsx":
<Route path="/parkingSpot/:id" element={<ParkingSpotPage />} />

Now it's working and we have the clue that out function is working properly.
Let's add a loading state to update the ui.
If we have an error, then update the ui with the error message.
If we don't have an error and a loading state, then we can actually return the ui.
"
if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="loading loading-spinner loading-lg" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="alert alert-error">{ error }</div>
      </div>
    );
  }
"
The actual ui:
"
const handleDelete = async () => {
    if (window.confirm("Are you sure you want to delete this product?")) {
      await deleteSpot(id);
      navigate("/");
    }
  };

[...]

  return (
    <div className="container mx-auto px-8 py-8 max-w-4xl">
      {/* Button to return to the HomePage,
      we navigate user back to the homepage */}
      <button onClick={() => navigate("/")} className="btn btn-ghost mb-8">
        <ArrowLeftIcon className="size-4 mr-2" />
        Back to all spots
      </button>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        {/* SPOT FORM */}
        <div className="card bg-base-100 shadow-lg">
          <div className="card-body">
            <h2 className="card-title text-2xl mb-6">Edit spot</h2>

            <form onSubmit={(e) => {
              e.preventDefault();
              updateSpot(id);
            }}
              className="space-y-6"
            >
              {/* SPOT STREET */}
              <div className="form-control">
                <label className="label">
                  <span className="label-text text-base font-medium">Spot street</span>
                </label>
                <input 
                  type="text"
                  placeholder="Enter spot street"
                  className="input input-bordered w-full"
                  value={formData.street}
                  onChange={(e) => setFormData({ ...formData, street: e.target.value })}
                />
              </div>

              {/* FORM TOT_AVAILABLE */}
              <div className="form-control">
                <label className="label">
                  <span className="label-text text-base font-medium">Number of free slots</span>
                </label>
                <input 
                  type="number"
                  min={0}
                  step={1}
                  placeholder="0"
                  className="input input-bordered w-full"
                  value={formData.tot_available}
                  onChange={(e) => setFormData({ ...formData, tot_available: e.target.value })} 
                />
              </div>

              {/* FORM ACTIONS */}
              <div className="flex justify-between mt-8">
                <button type="button" onClick={handleDelete} className="btn btn-error">
                  <Trash2Icon className="size-4 mr-2" />
                  Delete Spot
                </button>

                <button 
                  type="submit"
                  className="btn btn-primary"
                  disabled={ loading || !formData.street || !formData.tot_available }
                >
                  {loading ? (
                    <span className="loading loading-spinner loading-sm" />
                  ) : (
                    <>
                      <SaveIcon className="size-4 mr-2" />
                      Save changes
                    </>
                  )}
                </button>
              </div>

            </form>
          </div>

        </div>
      </div>
    </div>
  );
}
"
We can also use Link to navigate users to the different pages.




########################

Current state of the application:
- We are running our react application on localhost:5173
- Running our API, express server, on localhost:3000
Insetad of deploying these two separately, I would like to have both of them 
under the same domain. So, we will serve both of these under port 3000.
The entry point will be the backend and from here we will serve also the
static assets, which is going to be the frontend, the react application.

To configure this:
- Go to "frontend/" and delete the "node_modules" folder.
- Also delete the "node_modules" in the main "pern-app" folder
- There are two ".gitignore" (one in main folder, one inside frontend).
Cancel the once in "frontend" and copy all its content in the other one:
"
.env

# FRONTEND
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
" 
(Without specify that the elements comes from the "frontend" folder).

- Go to package.json in "pern-app" folder and create new script:
"build": "npm install && npm install --prefix frontend && npm run build --prefix frontend"
To run: "npm run build"
- Other script:
"start": "node backend/server.js"

- Now, go to "server.js":
"
import path from "path"; // Built in module

[...]
// To keep track of the directory that we are in
const __dirname = path.resolve();

[...]
app.use("/api/parkgingSpots", parkingSpotRoutes);

if (process.env.NODE_ENV==="production") {
    // Server our React application (static assets)
    app.use(express.static(path.join(__dirname, "/frontend/dist")));

    app.get("*", (req,res) => {
        res.sendFile(path.resolve(__dirname, "frontend", "dist", "index.html"));
    });
}
"

And in ".env" type:
"
NODE_ENV=development
"

Go to "useParkingSpotsData.js" and look at the BASE_URL:
"
// Base url will be dynamic depending on the environment 
const BASE_URL = import.meta.env.MODE === "development" ? "http://localhost:3000" : "my_domain.com";
"

Test this out by changing "NODE_ENV=production", and run:
"npm run build
npm start"
"

########################

The best way to start both your frontend (Vite) and backend
(Node/Express with Nodemon) with a single command from the root directory is to use
the concurrently package.
This setup is ideal for development because it runs the separate dev servers,
leveraging React's fast hot-reloading (Vite on 5173) while the backend API
runs on its port (3000), allowing the frontend to proxy/call the API as it does now.
- Install concurrently in the root directory (pern-app):
"npm install concurrently --save-dev"
- 
"
"dev": "concurrently \"npm run dev --prefix frontend\" \"nodemon backend/server.js\"",
"

#########################
To launch backend:
- pern-app> npm run dev
In another tab, launch frontend:
- pern-app\frontend> npm run dev

Now just: npm run start (with concurrently)

#########################

docker compose up
Stop the application by: docker compose down 


##################################
ATTENZIONE:
- cancellando l'elemento con id 4 e inserendo poi un nuovo elemento, questo 
non avr id 4, ma id 5.
- pur volendo modificare un solo attributo con updateParkingSpot,  necessario
inserire tutti gli elementi (bot required)



#################

created docker file for the react client.
FROM node:14-slim

WORKDIR /usr/src/app

COPY ./package.json ./
COPY ./yarn.lock ./

RUN yarn install

COPY . .

EXPOSE 3000

CMD ["yarn", "start"]


In server:
FROM node:14-slim

WORKDIR /usr/src/app

COPY ./package.json ./
COPY ./yarn.lock ./

RUN yarn install

COPY . .

EXPOSE 5000

CMD ["index.js"]


docker-compose.yml

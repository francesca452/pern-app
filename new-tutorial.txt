TUTORIAL: https://www.youtube.com/watch?v=lx3YJj0nJVk&t=10025s

1. cd pern-app
2. code .
3. mkdir backend
4. mkdir frontend
5. nmp init -y

6. npm i express dotenv cors helmet morgan @neondatabase/serverless @arcjet/node
"npm install" - for installing packages or libraries on backend.
We need to install express not in the backend ("cd backend") but in the pern-app enviorment.
You can look at your express version in package-lock.json (search for "express")

7. In backend folder create a new file called server.js 
8. Go to package.json file and modify "main" entry point, from "index.js" to "backend/server.js"

9. In server.js write "import express from "express";"
Is another way to say "const express = require("express");".
We have to insert below "author" entry point in package.json the entry point "type":
"type": "module" -> the default way is "commonjs", related to "const express = ...".

10. In server.js:
const app = express();
app.listen(3000, () => {
    console.log("Server is running on port 3000");
});
Then in terminal digit "node backend/server.js". This run the server.
But, instead of doing this every single time, we should create a script.
In package.json delete the "test" script, write new "dev" script:
"scripts": {
    "dev": "node backend/server.js"
},
In terminal, instead of "node/nodemon backend/server.js", we'll digit "npm run dev"
Now, in the terminal we see "server is running on port 3000" -> good that we don't see
"[nodemon] clean exit - waiting for changes before restart", meaning that the connection to
the server is shut down.

11. npm i nodemon -D
We see that the server is running on 3000 port. If we change "app.listen(3001, ...)"
and save, nothing change. If we want to restart the server automatically once we do a change
like this, we can use a package that kill the terminal.
After the command, we see "devDepencencies" new in package.json file
We can change the istruction to see the port changing:

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
--> LATER WE'LL USE IN ANOTHER WAY "PORT", so don't change.

12. First trying of request (in server.js file):
app.get("/", (req, res) => {
    res.send("Hello from the backend");
});

We can see the res sent in new tab in browser, at "http://localhost:PORT" (like :3000).
We can have also a route:
app.get("/test", (req, res) => {
    res.send("Hello from the test route");
});

and visualizable at "http://localhost:3000/test".
If you get wrong http link, you'll receive: "Cannot GET /".

13. We want to create an API. In server.js:
import helmet from "helmet";
import morgan from "morgan";

Before using the packages, we do a preliminary test for response:
app.get("/test", (req, res) => {
    console.log(res.getHeaders());
    res.send("hello from the test route");
});

In the terminal we only see information about: "x-powered-by": "Express".
Now, insert a middleware before app.get:
app.use(helmet());

Once we refresh the web page, we see in the terminal a lot of informations.
These informations are headers that will secure us to secure our application, like:
"x-xss-protection", "cross-domain-policies", and a lot of different things.
Like it's said by the comment: "helmet is a security middleware that helps you to
protect your app by setting various HTTP headers".

14. app.use(morgan("dev")); "dev" is an option: it will log the request.
In fact, if we return to web page and refresh, we can see in the terminal that
we've done GET request to the route "/test", and say that our response it not modify (304) 
and how it took to give the response (4.885 ms).
Normally we should assume to get 200 response, but since the response is in the cache, we got 304.
If we cancel the cache, by doing some command in the web page, we see the responce will be 200.
So, if response is 304, it means the response in coming from the cache.

15. Another middleware: app.use(express.json());
This will allow us to parse the incoming data, extract that json data.

16. app.use(cors());
Help us to not have cors errors in the client.
We need also "import cors from "cors";", not specify in the tutorial.

17. Now we have all middle layers. Now we can set the environment variables.
Instead of the hardcoded value like PORT=3000, we create a ".env" file (at the same level of backend).
PORT=3000 in .env file.
Don't use spaces!! (NOT PORT = 3000)

Go to server.js file, below "const app" write: "const PORT = process.env.PORT;".
Port has to be all uppercase: because is a constant.
"process.env.PORT" should come from .env.
If we only write "console.log(PORT);" we will have in the console "Undefined" for the port,
because we didn't use the package called "dotenv":
"import dotenv from "dotenv";"
And we have to wirte: "dotenv.config();"
If we don't want to see any dotenv promotional tip (like: [dotenv@17.2.3] injecting
env (1) from .env -- tip: ðŸ” encrypt with Dotenvx: https://dotenvx.com), we can
use "dotenv.config({ quiet: true });".
We don't have issue about having PORT inside .env that stay at the level of backend folder
(.env and backend at the same level, server.js inside backend), because when we run our server with
"nodemon backend/server.js" the current working directory is "pern-app/" (where package.json is), not the
backend folder. So, when "dotenv.config();" runs, it looks for ".env" in the current working directory, which 
is exactly where your ".env" file is located.

We can also use the command:
const PORT = process.env.PORT || 3000;

18. Before we can connect our database (postgres), we need to organize our server.js file,
to look clearly at our request and response from database.
We correct the route, from "/test" to "/api/parking-spots", because it has to be an API.
app.get("/api/parkingSpots", (req, res) => {
    
    // GET ALL PARKING SPOTS FROM DB
});

The response will be something like:
res.status(200).json({
    success: true,
    data: [ 
        { id: 1, name: "Parking spot 1" },
        { id: 2, name: "Parking spot 2" },
        { id: 3, name: "Parking spot 3" }    
    ],
});

API (application Programming Interface) allows two different application to talk
to each other. For example, we have a React application and we want to fetch some data 
from the database, there will be a "main in the middle" which is going to be our API.
Now, we want to set our APIs to communicate with our databaase and send a response 
back to the client. We will call the thing above API end points from our React application 
under the front end.
To make all organized, we create new folders: "backend/routes" and "backend/controllers".
In "routes" foulder create "parkingSpotRoutes.js". We're going to call express and create a router.

import express from "express";

const router = express.Router();

export default router;

In server.js we have to cancel:
app.get("/test", (req, res) => {
    res.send("Hello from the test route");
});

For rewrite like below, that will call the API endpoint:
app.use("/api/parkingSpots", parkingSpotRoutes);
That will only run by insert:
import parkingSpotRoutes from "./routes/parkingSpotRoutes.js";
(Remember to always add the extention ".js" because we chose the "type": "modules" in the setup)

19. In parkingSpotRoutes.js we write under "const router = express.Router();":
router.get("/test", (req, res) => {
    res.send("test route");
});
This is a test (we will see something at the route "http://localhost:3000/api/parkingSpots/test")
We'll also have in the console in the terminal:
GET /api/parkingSpots/test 200 11.373 ms - 10
(look at the 200 response code)

After a test, we write all the routes, for example:
router.get("/", (req, res) => {
    // GET ALL PARKING SPOTS
});

router.post("/", (req, res) => {
    // POST A PARKING SPOT
});

We know that this code will be super long, so we use the folder "controllers"
to set all the information. Create a new file: "controllers/parkingSpotController.js".
Adjust the content of parkingSpotRoutes.js like:

import { getAllParkingSpots, createParkingSpot } from "../controllers/parkingSpotController.js";

router.get("/", getAllParkingSpots);
router.post("/", createParkingSpot);

Go to the new file parkingSpotController.js:
export const getAllParkingSpots = async (req, res) => {};
export const createParkingSpot = async (req, res) => {}; 

Those will be async function, so we can call await.
Are necessary also other routes, like:
// delete parking spot
// modify parking spot

Later, we will modify the logic of the two request, because for now we don't have a database.

20. Now we connect our database. 
The tutorial boy used the enviorments arcjet and neon.
...

21. Create a new folder "config" inside "backend". Inside will be "db.js".
With this file, we can connect with our database.
Inside the file:

import { neon } from "@neondatabase/serverless";
import dotenv from "dotenv"; 

dotenv.config();

const { PGHOST, PGDATABASE, PGUSER, PGPASSWORD } = process.env;

Dotenv is necessary to access some enviorment variables (in .env file).
Also:

// Creates a SQL connection using our env enviorment
export const sql = neon(
    `postgresql://${PGUSER}:${PGPASSWORD}@${PGHOST}/{PGDATABASE}?sslmode=require`
);

/* This sql function we export is used as a tagged template literal, which allows
us to write SQL queries safely */

22. In "server.js" file we need a function to initialize the database.
import { sql } from "./config/db.js";

async function initDB() {
    try {
        ...
    } catch (error) {
        console.log("Error initDB", error);
    }
}

In the try section we want to create a table called parkingSpots.
We write await to get this SQL function from the "config/db.js";
and this is what we called a tagged template literal that'll be using.
try {
    await sql`
        CREATE TABLE IF NOT EXISTS parkingspots (
            id SERIAL PRIMARY KEY,
            street VARCHAR(255) NOT NULL,
            tot_available INTEGER NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    `;

    console.log("Database initialized successfully");
}
(Remember that this is a test for the real database for parking spots)
For id: "SERIAL" because we want to have all the parking spots in sequel ids.

We want to run the server only if database is ready.
We change this:
app.listen(PORT, () => {
    console.log("Server is running on port " + PORT);
});

In this:
initDB().then(() => {
    app.listen(PORT, () => {
        console.log("Server is running on port " + PORT);
    });
});

23. Next, we will build our controllers.
Add some routes in "routes/parkingSpotRoutes.js":
router.get("/", getParkingSpots); // Modify getAllParkingSpots in getParkingSpots
router.get("/:id", getParkingSpot); // For a specific parking spot
router.post("/", createParkingSpot);
router.put("/:id", updateParkingSpot);
router.delete("/:id", deleteParkingSpot);

Then, modify the same function in "controllers/parkingSpotController.js":
export const getParkingSpots = async (req, res) => {};
export const getParkingSpot = async (req, res) => {}; 
export const createParkingSpot = async (req, res) => {};
export const updateParkingSpot = async (req, res) => {}; 
export const deleteParkingSpot = async (req, res) => {};

Don't forget to adjust in "parkingSpotRoutes.js":
import { getParkingSpots, getParkingSpot, createParkingSpot, updateParkingSpot, deleteParkingSpot } from "../controllers/parkingSpotController.js";

If we visit in browser: "http://localhost:3000/api/parkingSpots/",
we'll be in loading state because we didn't already say something in the function:
router.get("/", getParkingSpots);
export const getParkingSpots = async (req, res) => {};

For now, we've deciding to use local database connection.
Changes in the file:
    - .env:
    "
    # Local PostgreSQL configuration
    PGUSER=postgres
    PGPASSWORD=4rancEsc@!
    PGHOST=localhost
    PGDATABASE=dbs
    PGPORT=5432
    "
    - db.jd:
    "
    import { Client } from "pg";
    import dotenv from "dotenv";

    dotenv.config();

    const { PGHOST, PGUSER, PGPORT, PGPASSWORD, PGDATABASE } = process.env;

    const con = new Client({
        host: PGHOST || "localhost",
        user: PGUSER || "postgres",
        port: PGPORT || 5432,
        password: PGPASSWORD,
        database: PGDATABASE || "dbs"
    });

    con.connect()
    .then(() => console.log("Connected to database"))
    .catch(err => console.error("Connection error: ", err));

    export const sql = con;
    "
    - server.js
    "
    import { sql } from "./config/db.js";
    [...]
    async function initDB() {
        try {
            await sql.query(`
                CREATE TABLE IF NOT EXISTS parkingspots (
                    id SERIAL PRIMARY KEY,
                    street VARCHAR(255) NOT NULL,
                    tot_available INTEGER NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            `);

            console.log("Database initialized successfully");
        } catch (error) {
            console.log("Error initDB", error);
            process.exit(1);
        }
    }

    initDB().then(() => {
        app.listen(PORT, () => {
            console.log("Server is running on port " + PORT);
        });
    });
    "

Tutorial used for changes: https://www.youtube.com/watch?v=VaJPdtuql8k
To see the information needed for .env setup, go to pgAdmin4 application,
click on: "Servers->PostgreSQL18->properties->connection"
Don't forget to: "npm install pg"
To see the new table created, go to "Servers->PostgreSQL18->dbs->Schemas->public->Tables",
now click on "parkingSpots->View/Edit data->All rows".

To add some values to the table, click on "dbs->Schemas->public->Tables->parkingsposts->Query tool",
and type:
- One row at a time:
"
INSERT INTO parkingspots (street, tot_available)
VALUES
    ('Via Cirro', 10)
RETURNING id;
"
- Multiple rows at a time:
"
INSERT INTO parkingspots (street, tot_available)
VALUES
 	('Via Marziale', 5),
	('Via Roma', 18),
	('Via Garibaldi', 7)
RETURNING id;
"
- To see all the changes:
"SELECT * FROM parkingspots;"

What "RETURNING id" does: when you insert new rows, PostgreSQL automaticaly creates
ids (because id is SERIAL, at the time of the table creation).
RETURNING id tells Postgres to: after inserting the rows, give me back the ids you created, 
and using pgAdmin, the ids will be show directly in the Data Output tab.
Same insert in javascript enviorment:
"
const result = await sql.query(`
  INSERT INTO parkingspots (street, tot_available)
  VALUES 
    ('Via Marziale', 5),
    ('Via Roma', 3)
  RETURNING id;
`);
"
Remember not to use "..." but '...'.

-----------------

24. Now, we complete the route function one by one.
We are not returning anything, so the browser is in loading state when we type a specific route of "parkingSpotRoutes.js".
We need to import sql from "db.js" file, to asking query to the database:
"import { sql } from '../config/db.js';"
First route:
- get(All)ParkingSpots in "parkingSpotControllers.js":
"
try {
        const spots = await sql.query(`
            SELECT * FROM parkingspots -> // * gave all the column 
            ORDER BY created_at DESC -> // order by the created_at field in the descending order
        `);
        # Then, we assign this into a variable called "sposts"
        # and return this as a responce 
        console.log(`Found ${spots.rows.length} parking spots`);
        res.status(200).json({ success: true, data: spots.rows }); # -> 200 if the get is succesfully done
    } catch (error) {...};
"

What we see in the page at route "http://localhost:3000/api/parkingSposts/" is just:
- With no elements: "{"success":true,"data":[]}"
- With some anticipated insert: 
{"success":true,"data":{"command":"SELECT","rowCount":4,"oid":null,"rows":[{"id":4,"street":"Via Cirro","tot_available":10, ...}

Complete with "catch" section.


25. We go with createParkingSpot().
First, we want to get some data that user will send us, because they want to create a new parking spot.
They're all coming from req.body:
"const { street, tot_available } = req.body; "
It's possible by the middleware "app.use(express.json());": with this, we can
destructure these values from the request body.
We create an "if" instruction if user didn't send us one of them. 
"if (!street || !tot_available) {
    return res.status(400).json({ success: false, message: "All fields are required" })
}"

Maybe, also some control inserting numbers for "tot_available".

Then, the try-and-catch block:
"
try {
        const newSpot = await sql.query(`
            INSERT INTO parkingspots (street, tot_available)
            VALUES ($1, $2)
            RETURNING *`,
            [street, tot_available]
            );
        // Safer than using: ${street} ${tot_available}

        // console.log("New spot created");
        res.status(201).json({ success: true, data: newSpot.rows[0] });

    } catch (error) {...};
};
"

"newSpot" is a record ([]), so we write newSpot.rows[0] to get the newky created spot.
We're going to test this function with a desktop application in the next moment: Postman.


26. Continue to fill the other function: getParkingSpot (get only one spot).
In "parkingSpotRoutes.js" file, the routes to call the function is:
"router.get("/:id", getParkingSpot);"
Note that the parameter "id" has to be in repeated in the body function of getParkingSpot.
(if I choose idx -> then I have to recall the param idx).

"
export const getParkingSpot = async (req, res) => {
    const { id } = req.params;

    try {
        const spot = await sql.query(`
            SELECT * FROM parkingspots WHERE id=$1`,
            [id]
        );
        // Remember the comma (,) !!
        // Safer than: `SELECT * FROM parkingspots WHERE id=${id}`

        // Check if the spot exists
        if (spot.rows.length === 0) {
            return res.status(404).json({
                success: false,
                message: "Parking spot not found"
            });
        }

        res.status(200).json({ success: true, data: spot.rows[0] });

    } catch (error) {...};
}; 
"

27. It's time for: updateParkingSpot
Function need to refer to the right element in the table.
Always pay attention to the route that leads to the function (from parkingSpotRoutes to
parkingSpotController). In this case, in the routes file: router.put("/:id", updateParkingSpot);
has id parameter: "const { id } = req.params;"

Because the user would like to update one of this fields, or maybe all of them,
they are both required (maybe that can change in the next update).
"
const { street, tot_available } = req.body;

try {
    const updatedSpot = await sql.query(`
        UPDATE parkingspots
        SET street=$1, tot_available=$2
        WHERE id=$3
        RETURNING *`,
        [street, tot_available, id]
    );

    # We also add a check
    if (updatedSpot.length === 0) { # If correct, that means product is not found
        return res.status(404).json({ success: false, message: "Spot not found"});
    }
        
    console.log("Succesfully updated");
    res.status(200).json({ success: true, data: updatedSpot.rows[0] });

} catch (error) {...};
"   


28. Last one function: deleteParkingSpot.
It's very similar to updateParkingSpot.

"
export const deleteParkingSpot = async (req, res) => {
    const { id } = req.params;

    try {
        const deletedSpot = await sql.query(`
            DELETE * FROM parkingspots WHERE id=$1
            RETURNING *`,
            [id]
        );

        if(deletedSpot.length === 0) {
            return res.status(404).json({ succes: false, message: "Spot not found" });
        }

        console.log("Parking spot removed");
        res.status(200).json({ success: true, message: deletedSpot.rows[0] });

    } catch (error) {...};
};
"

This was all the CRUD operations.

------------------

29. Having all the routes and the controllers, test them out in Postman application.
Create new workspace from a blank project (top). Create new blank collection called "PARKINGSPOTS" (top-left).
Create new request ("+" in PARKINGSPOTS collection). 

This will be a GET request: rename it "GET ALL PARKING SPOTS".
Type the endpoint: "http://localhost:3000/api/parkingSpots/" 
(remember: 
    - from "server.js" file: "app.use("/api/parkingSpots", parkingSpotRoutes);"
    (so, the "/api/parkingSposts")
    - from "parkingSpotRoutes": "router.get("/", getParkingSpots);"
    (so, the "/")
The result is the final endopoint)

Attention: the server need to be online!
"PS C:\Users\mazze\pern-app> npm run dev" -> see the log message "Server is running on port 3000".

The responce status will be: 200 OK. 


Create new request: POST, "CREATE NEW PARKING SPOT".
Go to the body section and have a reference to the createParkingSpot function:
-> "const { street, tot_available } = req.body;"
The API request don't need a params (no id), but in the body is necessary (both):
{
    "street":"Via ...",
    "tot_available":40 -> positive number!
}

Responce will be:
{
    "success": true,
    "data": {
        "id": 8,
        "street": "Via Rizzoli",
        "tot_available": 40,
        "created_at": "2025-11-21T11:03:32.529Z"
    }
}

You can control the newly row by the "GET ALL PARKING SPOTS" API request.

Other request: GET, "GET A SINGLE PARKING SPOT", with endopoint "http://localhost:3000/api/parkingSpots/:id".
To get a specific element, we can:
- Insert the id in the params section (in "Path Variables", in corrisponce of "id")
- Change the "/:id" with the specific one, like "http://localhost:3000/api/parkingSpots/4"

Sending the request, you'll receive "success:true" with all the attributes.

Request: DELETE, "DELETE A SINGLE PARKING SPOT".
Like the GET request, insert the id of the parking spot.

Request: PUT, "UPDATE PARKING SPOT".
For now, we are receiving both the elements in request body for "street" and "tot_available", like:
{
    "street":"Via Don Bedetti 89",
    "tot_available":5
}
For example, if you want to update only the street name, the number of total spots is still needed,
even if they remain unchanged.
In params body, insert also the id number.

Next, we will do the same request from the frontend application.

------------------

30. Definition of rate limiting: strategy for limiting network traffic. 
It puts a limit on how often someone can repeat an action within a certain timeframe.
Let's think about a malicious/bad user that wants to send 1000 req/sec.
Our server would crash in that case, we can't handle that amount of requests per sec.
So, we're going to put a limit: every user can only send 20 requests per minute.
How we can keep track of single user or all of them: by the IP address.
Also, we're implementing bot detection and Shield.

Go to "Arcjet->Docs->Node,js + Express" (https://docs.arcjet.com/get-started?f=node-js-express):
- "npm install express" -> Already done
- "npm i @arcjet/node @arcjet/inspect" -> Need to install inspect (updated in the last year)
- Set the keys (in ".env" file):
--> ARCJET_KEY=...: copy when creating new account
--> ARCJET_ENV=development: tells Arcjet you're working locally,
so it will accept your local IP address (127.0.0.1 or localhost).
Needed because Node.js doesn't set NODE_ENV for you.
- We add some code in a new folder, specifically for Arcjet porpouse:
--> "Backend->lib->arcjet.js"
("lib" for configure third parties libraries)
Then look and copy from the documentation.

arcjet.js:
"
import arcjet, { tokenBucket, shield, detectBot } from "@arcjet/node";

// Initialize Arcjet
const aj = arcjet({
    key: process.env.ARCJET_KEY,
    characteristics: ["ip.src"],
    rules: [
        shield({ mode:"LIVE" }),
        detectBot({
            mode:"LIVE",
            allow:["CATEGORY:SEARCH_ENGINE"],
        }),
        tokenBucket({
            mode: "LIVE",
            refillRate: 5,
            interval: 10,
            capacity: 10
        }),
    ],
});

export { aj };
"

tokenBucket algorithm params:
- refillRate: 5 (how many tokens we're going to get)
- interval: 10 (seconds)
- capacity: 10 (tokens)
- requested: 1 (each request consumes 1 token)

With capacity of 10, initially we have 10 tokens:
0s: 10 tokens
1s: make 3 req -> 7 tokens left 
2s: make 3 req -> 4 tokens left
3s: make 4 req -> 0 tokens left (capacity)
4s: try req -> rate limited
10s (interval): refill (+ 5 tokens)
20s: refil (+5 tokens)

Other algorithm: slidingWindows (instead of tokenBucket).
Unfortunetly, we can actually test this out only from the homepage (frontend).

In "server.js":
"
[...]
import { aj } from "./lib/arcjet.js";
import { isSpoofedBot } from "@arcjet/inspect";
[...]

// Middleware
[...]

// Apply Arcjet rate limit to all route
// Just below Middleware
app.use(async (req,res,next) => {
    try {
        const decision = await aj.protect(req, { requested:1 });

        if (decision.isDenied()) {
            if (decision.reason.isRateLimit()) {
                return res.status(429).json({ error: "Too many requests" });
            } else if (decision.reason.isBot()) {
                return res.status(403).json({ error: "No bots allowed" });
            }
            return res.status(403).json({ error: "Forbidden" });
            
        } else if (decision.ip.isHosting()) {
            return res.status(403).json({ error: "Forbidden" });
            
        } else if (decision.results.some(isSpoofedBot)) {
            return res.status(403).json({ error: "Forbidden" });
            
        } 
        
        next();

    } catch (error) {
        console.log("Arcjet error", error);
        next(error);
    }
});

app.use("/api/parkingSpots", parkingSpotRoutes);

[...]
"
"mport dotenv/config" must be the first import in entry file (server.js),
so environment variables are loaded before any other module tries to use them.
We don't need to import dotenv also in "arcjet.js" file.


--------------------------------------------------------------------

FRONTEND IMPLEMENTATION
We'll create frontend application.

1. Go to terminal: "cd frontend"
2. "npm create vite@latest ." // To initialized it into the frontend folder
3. Choose "React" and "Javascript" (for beginner friendly, but can be used also Typescript)
(Need to reinstall the latest version of Node.js)
4. npm install
5. npm run dev 
6. We can visit local: http://localhost:5137/.
You will see a 'default' react application.
7. We cancel some files:
- "frontend/src/App.css"
- "frontend/src/assets"
- In "frontend/src/App.jsx" cancel all the text and write new one:
"
function App() {
    return (
        <div>
            <h1>hey</h1>
        </div>
    );
}

export default App
"

8. Use Tailwindcss version 3.4.17: click in the top left choise version (v4.1/v3.4.17),
then go to "Docs->Installation->Framework Guides->Vite->Using React"
(https://v3.tailwindcss.com/docs/guides/vite).
In the terminal:
- Create your project: "npm create vite@latest" -> OK
- Install Tailwind CSS: "npm install -D tailwindcss@3 postcss autoprefixer"
- "npx tailwindcss init -p"
Now in frontend folder there're two more files: "postcss.config.js" and "tailwind.config.js"
- Configure your template paths: 
in "tailwind.config.js" file add the code below:
"
[...]
content: [
    "/index.html",
    "./src/**/*.{js,ts,jsx,tsx}"
],
"
- Add the Tailwind directives to your CSS:
in "./src/index.css" file, add the "@tailwind" directive.
Cancel everything that we have in the file and add:
"
@tailwind base;
@tailwind components;
@tailwind utilities;
"

To test the correct connection with Tailwind, go to "frontend/src/App.jsx" and add
a className to the <h1> tag: "<h1 className="text-red-500">".
If it's not available the auto suggestion, go to extensions option of vscode and install:
- Tailwind CSS IntelliSense
- ES7+ React/Redux/React-Native
(for example: if I type "rfce", I will see some default code).

9. "npm run dev" to restart the frontend (the path has to be "[...]pern-app\frontend> npm run dev").
10. Go to DaisyUI v4x and install that, as the pre-built components on top of Tailwind:
(https://v4.daisyui.com/docs/install/).
- In the terminal type: "npm i -D daisyui@v4"
- Add daisyUI to "tailwind.config.js" (using import-export):
"
import daisyui from "daisyui";
export default {
    [...]
    plugins: [daisyui],
}
"
If you want some different daisyui themes, you can add them like:
"
import daisyui from "daisyui";
export default {
    [...]
    plugins: [daisyui],
    daisyui: {
        themes: [
        "pastel",
        "retro", 
        [...]
        ],
    }
}
"

11. Other installation: "npm i react-hot-toast react-router-dom axios zustand lucide-react"
- "react-hot-toast": library that shows notification
- "react-router-dom": allows us to have the navigation in place (to have links, different pages)
- "axios": to fetch data and to send requests (replacement for "fetch API")
- "zustand": for global state
- "lucide-react": package used for icons

12. Create two different folders in "frontend/src": "components" and "pages".
13. In "pages" create "HomePage.jsx" file: type "rfce" to get the initial code.
14. Also create "ParkingSpotsPage.jsx", type rfce.
15. For the components, let's say we have: "Navrbar.jsx".
16. In "App.jsx" delete latest <h1> element and write:
"
import Navbar from "./components/Navbar.jsx";
import HomePage from "./pages/HomePage.jsx";
import ParkingSpotPage from "./pages/ParkingSpotPage.jsx";

import { Routes, Route } from "react-router-dom";

function App() {
  return (
    <div className="min-h-screen bg-base-200 transition-colors duration-300">
      
      <Navbar />

      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/parkingSpot/:id" element={<ParkingSpotPage />} />
      </Routes>

    </div>
  );
}

export default App
"

Import the component and the pages, call it like a tag (React syntax).
"react-router-dom" allows to change the pages by selecting a different route.
For now, the Navbar is fixed on top of the page, and then:
- "htpp://localhost:5173/" --> Navbar / HomePage
- "http://localhost:5173/parkingSpot/23": --> Navbar / ParkingSpotPage

It is just to understand how do the pages work.
What makes this possible is also the "<BrowserRouter>" tag in "main.jsx" page,
that could be also used to incampsule all the code in "App.jsx".
"
createRoot(document.getElementById('root')).render(
  <StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </StrictMode>,
)
"

17. Now we can start the functionality of the navbar.
In the first div:
- <div className="bg-base-100/80 backdrop-blur-lg border-b border-base-conten/10 sticky top-0 z-50">
Then will have one more <div> with some classes:
- <div className="max-w-7xl mx-auto">
Then the wrapper for the navbar class:
- <div className="navbar px-4 minh-[4rem] justify-between">
(the "navbar" is a class of daisyui)
Insert now the logo, once clicked leds to the "HomePage".

The code below comes from Tailwindcss utility classes:
"
import { Link } from "react-router-dom";
import { ShoppingCartIcon } from "lucid-react";
[...]

<div className="flex-1 lg:flex-none">
    <Link to="/" className="hover-opacity-80 transition-opacity">
        <div className="flex items-center gap-2">
            <ShoppingCartIcon className="size-9 text-primary" />
            <span className="font-semibold font-mono tracking-widest text-2xl bg-clip-text text-trasparent bg-gradient-to-r from-primary to-secondary">
                POSGRES PARKING SPOT
            </span>
        </div> 
    </Link>
</div>
"

To change the color theme of the application, go to "App.jsx" theme and in the
<div> in the return section, and add "data-theme" attribute (choose between theme in "tailwind.config.js"):
"
<div className="min-h-screen bg-base-200 transition-colors duration-300" data-theme="cupcake">
"

Now, in "http://localhost:5173" we see the navbar modify.
To add some elements in the right part, we write:
"
import { Link, useResolvedPath } from "react-router-dom";
import { ShoppingBagIcon, ShoppingCartIcon } from "lucide-react";

function Navbar() {
  const { pathname } = useResolvedPath();
  const isHomePage = pathname === "/";

  return(
  [...]

    {/* RIGHT SECTION */}
        <div className="flex items-center gap-4">
            <p>ThemeSelector</p>

            { isHomePage && (
              <div className="indicator">
                <div className="p-2 rounded-full hover:bg-base-200 transition-colors">
                  <ShoppingBagIcon className="size-5" />
                  <span className="badge badge-sm badge-primary indicator-item">
                    8
                  </span>
                </div>
              </div>
            )}
        </div>
  [...]

)
}
"

The hook "useResolvePath" comes from react-router-dom. From this, we destructure the path name:
"isHomePage" will be true if "pathname === "/"", and we can show the element in the {...}:
"
<div className="indicator">
    <div className="p-2 rounded-full hover:bg-base-200 transition-colors">
        <ShoppingBagIcon className="size-5" />
        <span className="badge badge-sm badge-primary indicator-item">
            8
        </span>
    </div>
</div>
"

The 8 stand for element (products, but for our will be parking spots).

Now we can also adjust the "theme color" choice, inserting new component.


[..........]
Look at the commit "theme selection from the navbar"
[..........]


18. Fetch the data that we have in the database.
I don't want to fetch the data in the "HomePage" component, but from another file: "store\useParkingSpotsData.js".
"
import { create } from "zustand";

export const useParkingSpotsData = create((set,get) => ({
    // Spot state
    spots: [],
    loading: false,
    error: null,
}))
"
Once we fetch the spots, the attribute will update.

import { create } from "zustand";
import axios from "axios";

const BASE_URL = "http://localhost:3000";

export const useParkingSpotsData = create((set,get) => ({
    # Spot state
    spots: [],
    loading: false,
    error: null,

    fetchSpots: async () => {
        set({ loading:true }); # Because we're trying to fetch some data
    
        try {
            const response = await axios.get(`${BASE_URL}/api/parkingSpots/`) // We want to send a get request with the help of axios
            set({ spots:response.data.data, error:null });
            
            # Because the first data comes from axios.
            # The second data comes from our API in "parkingSpotControllers.js":
            # -> getParkingSpots() (for example):
            # [...]
            # res.status(200).json({
            # success: true,
            # data: spots.rows --> THIS DATA FIELD
            # });    

            "error:null" because we're in the try (so successfull) field

        } catch (err) {
            # Rate limiting
            if(err.status === 429) set({ error: "Rate limit exceeded" });
            else set({ error: "Something went wrong" });

        } finally { # Either we succeeded or not, we wanna set the loading state to false
            set({ loading:false });
        }
    }
}));

Pay attention:
- In "backend\server.js": "const PORT = process.env.PORT || 3000;"
The localhost set to 3000.
- Also: "app.use("/api/parkingSpots", parkingSpotRoutes);"
Endopoint to do some request: "http://localhost:3000/api/parkingSpots".
- In "backend\routes\parkingSpotRoutes.js": "router.get("/", getParkingSpots);". 
To do get request for "getParkingSpots()" set the endpoint: "http://localhost:3000/api/parkingSpots/".

So, in "frontend\store\useParkingSpotsData.js":
- const BASE_URL = "http://localhost:3000";
- const response = await axios.get(`${BASE_URL}/api/parkingSpots/`)

Now, go to "frontend\pages\HomePage.jsx" and try to call the function to fetch:
"
import React from "react";
import { useEffect } from "react";
import { useParkingSpotsData } from "../store/useParkingSpotsData";

function HomePage() {
  const { spots, loading, error, fetchSpots } = useParkingSpotsData(); 

  # We call the function "fetchSpots" with "useEffect":
  useEffect(() => {
    fetchSpots()
  }, [fetchSpots]);

  console.log("spots:", spots);

  return (
    <div>HomePage</div>
  )
}

export default HomePage;
"

In the console on web, we see spots (6) because these are the elements already in our database.
The get fetch function allows us to fetch the data (without using postman, but directly in the web application).

Now, we want to display them and we're gonna write the code in the "HomePage" return section:
"
import { PlusCircleIcon, RefreshCwIcon } from "lucid-react";
[...]

return (
    <main className="max-w-6xl mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-8">
        -> The functionality of this will be presented later
        <button className="btn btn-primary ">
          <PlusCircleIcon className="size-5 mr-2" />
          Add spot
        </button>

        -> Button to recall the fetch function (refresh the page with all elements)
        <button className="btn btn-ghost btn-circle" onClick={ fetchSpots }>
          <RefreshCwIcon className="size-5" />
        </button>

      </div>
    </main>
  )
"

Code to show an error indicator:
"
import SpotCard from "../components/SpotCard.jsx";
[...]
    <main>
    [...]

      -> Classes come from daisyui:
      -> What we rendere in case of error (not null from the fetch request)
      {error && <div className="alert alert-error mb-8">{ error }</div>}

      -> What we render during loading state:
      {loading ? (
        <div className="flex justify-center items-center h-64">
          <div className="loading loading-spinner loading-lg" />
        </div>
      ) : (
        -> In case of not loading, get each spots and for each spot we wold like 
          to return a component called SpotCard, a component that we're going to create
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {spots.map(spot => (
            <SpotCard key={spot.id} spot={spot} />
          ))}
        </div>
      )}

    </main>
"

Where "components\SpotCard.jsx" is:
"
import React from "react";

function SpotCard({spot}) {
    console.log(spot);

    return (
        <div>SpotCard</div>
    )
}

export default SpotCard;
"
It may has a problem with properties (spot)
(warning in the tutorial was like: spot is missing in props validation eslint(react/prop-types)).
Go to "frontend\eslint.config.js" and scroll to the "rules" field:
"react/prop-types": "off"
--> FOR NOW I DON'T WRITE THIS.

In the web page we can see 6 "SpotCard".
Now, we type some other text in the return field:
"
import React from "react";
import { Link } from "react-router-dom";
import { EditIcon, Trash2Icon } from "lucide-react";

function SpotCard({spot}) {

    return (
        <div className="card bg-base-100 shadow-xl hover:shadow-2xl transition-shadow duration-300">
            
            {/* SPOT IMAGE */}
            {/*
            <figure className="relative pt-[56.25%]">
                <img src={spot.image} alt={spot.street} className="absolute top-0 left-0 w-full h-full object-cover" />
            </figure>
            */}

            <div className="card-body">
                {/* SPOT INFORMATION */}
                <h2 className="card-title text-lg font-semibold">{ spot.street }</h2>
                <p className="text-2xl font-bold text-primary">{spot.tot_aviable}</p>

                {/* CARD ACTIONS:
                - Edit button: once click will take you to the spot page.
                The page will be created later
                - Delete button
                */}
                <div className="card-actions justify-end mt-4">
                    <Link to={`/spot/${spot.id}`} className="btn btn-sm btn-info btn-outline">
                        <EditIcon className="size-4" />
                    </Link>

                    <button className="btn btn-sm btn-error btn-outline">
                        <Trash2Icon className="size-4" />
                    </button>

                </div>

                
            </div>
            

        </div>       
    )
}

export default SpotCard;
"

To see if the rate limiting error work, click in teh web page numerous number of times the refresh button:
you will see the messa in a red box on top of the page saying "Rate limiting exceeded".
When we see this message, we can't see the spots.
Let's fix this:
go to "useParkingSpotsData", in the "catch" field:
"
catch (err) {
    if(err.status === 429) set({ error: "Rate limit exceeded", spots: [] });
    else set({ error: "Something went wrong", spots: [] });    
}
"
Add the "spots: []" to stop seeing the elements.


19. Now, we go back to "useParkingSpotsData" and add a function to delete a product.
The function will be call once you click on the delete icon in "SpotCard".
"
// It's necessary the id of the spot that we're gonna delete
    deleteSpot: async (id) => {
        set({ loading: true });

        try {
            await axios.delete(`${BASE_URL}/api/parkingSpots/${id}`);
            // We're gonna reset the previous state after the delete
            set((prev) => ({ spots: prev.spots.filter(spot => spot.id !== id )}));
            toast.success("Product deleted successfully");

        } catch (err) {
            console.log("Error in deleteSpot function", err);
            toast.error("Something went wrong"); 
        
        } finally {
            set({ loading: false });
        }

    },
"
Need the import of "import toast from "react-hot-toast";", because
we want to see if the spot is deleted (but we don't want to use the same
red message used to rate limiting error).
In "App.jsx" file, we need to add:
"
import { Toaster } from "react-hot-toast"; <-- THIS IMPORT

function App() {
  const { theme } = useThemeStore();
  
  return (
    <div className="min-h-screen bg-base-200 transition-colors duration-300" data-theme={ theme }>
      
      <Navbar />

      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/parkingSpot/:id" element={<ParkingSpotPage />} />
      </Routes>

      <Toaster /> <--- ADD THIS

    </div>
  );
}
"

Now, we can call the function in the "SpotCard" component:
"
<button
    className="btn btn-sm btn-error btn-outline"
    onClick={() => deleteSpot(spot.id)} <-- ADD THIS
>
    <Trash2Icon className="size-4" />
</button><>
"

To finish, we add a comment if the database is empty.
We add some code in "HomePage.jsx" after the error line:
"
import { PlusCircleIcon, RefreshCwIcon, PackageIcon } from "lucide-react";
[...]

{spots.length === 0 && !loading && (
    <div className="flex flex-col justify-center items-center h-96 space-y-4">
        <div className="bg-base-100 rounded-full p-6">
            <PackageIcon className="size-12" />
        </div>
        <div className="text-center space-y-2">
            <h3 className="text-2xl font-semibold">No spots found</h3>
            <p className="text-gray-500 max-w-sm">
              Get started by adding first spots to the inventory
            </p>
        </div>
    </div>
)}
"

20. Add spots.
Clicking the button "Add spot" in the HomePage, we would like to see some kind of modul 
where we can add spot street and tot_available free parking slot, and when submitm it will 
be saved in the database and it will update the web application interface.

Like the other functions, we add in "useParkingSpotsData.js" the function "addSpot".
We need also an object where we can locally write the input to be saved in the database.
"
// Form state
formData: {
    street:"",
    tot_available:0
}
"
Add also a function to help update the form state:
"
setFormData: (formData) => set({ formData }),
resetForm: () => set({ formData: { street:"", tot_available:0 } }),
"

And then the function:
"
// It's gonna take the event "e" because this will be the form submission
addSpot: async (e) => {
    e.preventDefault();
    set({ loading: true });

    try {
    // We want the data from formData. To call them inside a function we used the method "get"
    // as a param of "useParkingSpotsData()"
        const { formData } = get();
        // "formData" is like the req.body
        await axios.post(`${BASE_URL}/api/parkingSpots/`, formData); 
        // To show all the data in the page
        await get().fetchSpots();
        // "resetForm()" because we just add a new spot
        get().resetForm();
        // toast for successfull message
        toast.success("Spot added successfully");
        // Close the modal

    } catch (err) {
        console.log("Error in addSpot function", err);
        toast.err("Something went wrong");

    } finally {
        set({ loading: false });
    }
}
"

We create the component that's gonna be called "addSpotModal".
Go to "HomePage" and write "<AddSpotModal />" just abow the "error" field.
Create in the "components" folder the "AddSpotModal.jsx" file.
In the web interface don't see anything new.

Go to "AddSpotModal.jsx" and write the code for the modal:
(it's possible to go to daisyui web page and copy the element):
"
import React from "react";
import { useParkingSpotsData } from "../store/useParkingSpotsData";
import { Package2Icon, ParkingSquareIcon } from "lucide-react";

function AddSpotModal() {
    const { addSpot, formData, setFormData } = useParkingSpotsData();

    return (
        <dialog id="add_spot_modal" className="modal">
            <div className="modal-box">
                {/* CLOSE BUTTON */}
                <form method="dialog">
                    <button className="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">X</button>
                </form>

                {/* MODAL HEADER */}
                <h3 className="font-bold text-xl mb-8">Add new spot</h3>
                
                <form onSubmit={addSpot} className="space-y-6">
                    <div className="grid gap-6">
                        {/* SPOT STREET INPUT */}
                        <div className="form-control">
                            <label className="label">
                                <span className="label-text text-base font-medium">Street name</span>
                            </label>
                            <div className="relative">
                                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none text-base-content/50">
                                    <Package2Icon className="size-5" />
                                </div>
                                <input 
                                    type="text"
                                    placeholder="Enter spot street name"
                                    className="input input-bordered w-full pl-10 py-3 focus:input-primary transition-colors duration-200" 
                                    value={ formData.street }
                                    onChange={(e) => setFormData({ ...formData, street: e.target.value })}
                                />
                            </div>
                        </div>

                        {/* SPOT TOT_AVAILABLE */}
                        <div className="form-control">
                            <label className="label">
                                <span className="label-text text-base font-medium">Number of free slots</span>
                            </label>
                            <div className="relative">
                                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none text-base-content/50">
                                    <ParkingSquareIcon className="size-5" />
                                </div>
                                <input 
                                    type="number"
                                    min={0}
                                    step={1}
                                    placeholder="0"
                                    className="input input-bordered w-full pl-10 py-3 focus:input-primary transition-colors duration-200"
                                    value={formData.tot_available}
                                    onChange={(e) => setFormData({ ...formData, tot_available: e.target.value })} 
                                />
                            </div>
                        </div>

                    </div>
                </form>
            
            </div>
        </dialog>
    )
}

export default AddSpotModal;
"

In the web page when click on "Add spot" nothing changes. Because we didn't add on click function.
We have to go to "HomePage" file and add "onClick" event in the button tag:
"
<button className="btn btn-primary"
  ---> ADDED:  onClick={() => document.getElementById("add_spot_modal").showModal()}
>
    <PlusCircleIcon className="size-5 mr-2" />
    Add spot
</button>
"

Destructure:
- document: from the document...
- .getElementById("add_spot_modal"): find an element with this id...
That is the <dialog> id in the AddSpotModal return field.
- .showModal(): and we're gonna call the showModal() method.

Now we see the modal open, but we can't close it by touching the background. 
We have to add from ui: go to "AddSpotModal.jsx" and at the bottom of "<dialog>" write
a backdrop component (not a real component)
"
{/* BACKDROP */}
<form method="dialog" className="modal-backdrop">
    <button>close</button>
</form>
"

The only thing that we are missing is the actions: cancel button and a submit button in the modal.
We can add both in the <form> tga into "AddSpotModal.jsx":
"
{/* MODAL ACTIONS */}
<div className="modal-actions">
    <button 
        className="btn btn-ghost mr-3"
        onClick={() => setFormData({ street:"", tot_available:0 })}
    >
        Cancel
    </button>
    <button
        type="submit"
        className="btn btn-primary min-w-[120px]"
        disabled={!formData.street || !formData.tot_available || loading}
    >
        {loading ? (
            <span className="loading loading-spinner loading-sm" />
        ) : (
            <>
                <PlusCircleIcon className="size-5 mr-2" />
                Add spot
            </>
        )}
    </button>
</div>
"

To automatically close the modal once inserted new spot, return to "useParkingSpotsData" from "addSpot":
"
document.getElementById("add_spot_modal").close();
"
in the try field below the "toast.success".


21.




#########################
To launch backend:
- pern-app> npm run dev
In another tab, launch frontend:
- pern-app\frontend> npm run dev



#########################
ATTENZIONE:
- cancellando l'elemento con id 4 e inserendo poi un nuovo elemento, questo 
non avrÃ  id 4, ma id 5.
- pur volendo modificare un solo attributo con updateParkingSpot, Ã¨ necessario
inserire tutti gli elementi (bot required)